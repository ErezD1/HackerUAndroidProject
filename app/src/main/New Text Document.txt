6. Use ViewModel with data binding
Next you will use data binding to bind the view model data to the UI. You will also update the shared view model based on the selections the user makes in the UI.

Refresher on Data binding
Recall that the Data Binding Library is a part of Android Jetpack. Data binding binds the UI components in your layouts to data sources in your app using a declarative format. In simpler terms, data binding is binding data (from code) to views + view binding (binding views to code). By setting up these bindings and having updates be automatic, this helps you reduce the chance for errors if you forget to manually update the UI from your code.

Update flavor with user choice
In layout/fragment_flavor.xml, add a <data> tag inside the root <layout> tag. Add a layout variable called viewModel of the type com.example.cupcake.model.OrderViewModel. Make sure the package name in the type attribute matches with the package name of the shared view model class, OrderViewModel in your app.

<layout ...>

    <data>
        <variable
            name="viewModel"
            type="com.example.cupcake.model.OrderViewModel" />
    </data>

    <ScrollView ...>

    ...
Similarly, repeat the above step for fragment_pickup.xml, and fragment_summary.xml to add the viewModel layout variable. You will use this variable in later sections. You don't need to add this code in fragment_start.xml, because this layout doesn't use the shared view model.
In the FlavorFragment class, inside onViewCreated(), bind the view model instance with the shared view model instance in the layout. Add the following code inside the binding?.apply block.

binding?.apply {
    viewModel = sharedViewModel
    ...
}
Apply scope function
This may be the first time you're seeing the apply function in Kotlin. apply is a scope function in the Kotlin standard library. It executes a block of code within the context of an object. It forms a temporary scope, and in that scope, you can access the object without its name. The common use case for apply is to configure an object. Such calls can be read as "apply the following assignments to the object."

Example:


clark.apply {
    firstName = "Clark"
    lastName = "James"
    age = 18
}

// The equivalent code without apply scope function would look like the following.

clark.firstName = "Clark"
clark.lastName = "James"
clark.age = 18
Repeat the same step for the onViewCreated()method inside the PickupFragment and SummaryFragment classes.

binding?.apply {
    viewModel = sharedViewModel
    ...
}
In fragment_flavor.xml, use the new layout variable, viewModel to set the checked attribute of the radio buttons based on the flavor value in the view model. If the flavor represented by a radio button is the same as the flavor that's saved in the view model, then display the radio button as selected (checked = true). The binding expression for the checked state of the Vanilla RadioButton would look like the following:
@{viewModel.flavor.equals(@string/vanilla)}

Essentially, you are comparing the viewModel.flavor property with the corresponding string resource using the equals function, to determine if the checked state should be true or false.

Note: Remember that binding expressions start with an @ symbol and are wrapped inside curly braces {}.


<RadioGroup
   ...>

   <RadioButton
       android:id="@+id/vanilla"
       ...
       android:checked="@{viewModel.flavor.equals(@string/vanilla)}"
       .../>

   <RadioButton
       android:id="@+id/chocolate"
       ...
       android:checked="@{viewModel.flavor.equals(@string/chocolate)}"
       .../>

   <RadioButton
       android:id="@+id/red_velvet"
       ...
       android:checked="@{viewModel.flavor.equals(@string/red_velvet)}"
       .../>

   <RadioButton
       android:id="@+id/salted_caramel"
       ...
       android:checked="@{viewModel.flavor.equals(@string/salted_caramel)}"
       .../>

   <RadioButton
       android:id="@+id/coffee"
       ...
       android:checked="@{viewModel.flavor.equals(@string/coffee)}"
       .../>
</RadioGroup>
Listener bindings
Listener bindings are lambda expressions that run when an event happens, such as an onClick event. They are similar to method references such as textview.setOnClickListener(clickListener) but listener bindings let you run arbitrary data binding expressions.

In fragment_flavor.xml, add event listeners to the radio buttons using listener bindings. Use a lambda expression with no parameters and make a call to the viewModel.setFlavor() method by passing in the corresponding flavor string resource.

<RadioGroup
   ...>

   <RadioButton
       android:id="@+id/vanilla"
       ...
       android:onClick="@{() -> viewModel.setFlavor(@string/vanilla)}"
       .../>

   <RadioButton
       android:id="@+id/chocolate"
       ...
       android:onClick="@{() -> viewModel.setFlavor(@string/chocolate)}"
       .../>

   <RadioButton
       android:id="@+id/red_velvet"
       ...
       android:onClick="@{() -> viewModel.setFlavor(@string/red_velvet)}"
       .../>

   <RadioButton
       android:id="@+id/salted_caramel"
       ...
       android:onClick="@{() -> viewModel.setFlavor(@string/salted_caramel)}"
       .../>

   <RadioButton
       android:id="@+id/coffee"
       ...
       android:onClick="@{() -> viewModel.setFlavor(@string/coffee)}"
       .../>
</RadioGroup>
Run the app and notice how the Vanilla option is selected by default in the flavor fragment.
3095e824b4817b98.png

Great! Now you can move onto the next fragments.

7. Update pickup and summary fragment to use view model
Navigate through the app and notice that in the pickup fragment, the radio button option labels are blank. In this task, you will calculate the 4 pickup dates available and display them in the pickup fragment. There are different ways to display a formatted date, and here are some helpful utilities provided by Android to do this.

Create pickup options list
Date formatter
The Android framework provides a class called SimpleDateFormat, which is a class for formatting and parsing dates in a locale-sensitive manner. It allows for formatting (date → text) and parsing (text → date) of dates.

You can create an instance of SimpleDateFormat by passing in a pattern string and a locale:

SimpleDateFormat("E MMM d", Locale.getDefault())

A pattern string like "E MMM d" is a representation of Date and Time formats. Letters from 'A' to 'Z' and from 'a' to 'z' are interpreted as pattern letters representing the components of a date or time string. For example, d represents day in a month, y for year and M for month. If the date is January 4 in 2018, the pattern string "EEE, MMM d" parses to "Wed, Jul 4". For a complete list of pattern letters, please see the documentation.

A Locale object represents a specific geographical, political, or cultural region. It represents a language/country/variant combination. Locales are used to alter the presentation of information such as numbers or dates to suit the conventions in the region. Date and time are locale-sensitive, because they are written differently in different parts of the world. You will use the method Locale.getDefault() to retrieve the locale information set on the user's device and pass it into the SimpleDateFormat constructor.

Locale in Android is a combination of language and country code. The language codes are two-letter lowercase ISO language codes, such as "en" for english. The country codes are two-letter uppercase ISO country codes, such as "US" for the United States.

Now use SimpleDateFormat and Locale to determine the available pickup dates for the Cupcake app.

In OrderViewModel class, add the following function called getPickupOptions() to create and return the list of pickup dates. Within the method, create a val variable called options and initialize it to mutableListOf<String>().

private fun getPickupOptions(): List<String> {
   val options = mutableListOf<String>()
}
Create a formatter string using SimpleDateFormat passing pattern string "E MMM d", and the locale. In the pattern string, E stands for day name in week and it parses to "Tue Dec 10".

val formatter = SimpleDateFormat("E MMM d", Locale.getDefault())
Import java.text.SimpleDateFormat and java.util.Locale, when prompted by Android Studio.

Get a Calendar instance and assign it to a new variable. Make it a val. This variable will contain the current date and time. Also, import java.util.Calendar.

val calendar = Calendar.getInstance()
Build up a list of dates starting with the current date and the following three dates. Because you'll need 4 date options, repeat this block of code 4 times. This repeat block will format a date, add it to the list of date options, and then increment the calendar by 1 day.

repeat(4) {
    options.add(formatter.format(calendar.time))
    calendar.add(Calendar.DATE, 1)
}
Return the updated options at the end of the method. Here is your completed method:

private fun getPickupOptions(): List<String> {
   val options = mutableListOf<String>()
   val formatter = SimpleDateFormat("E MMM d", Locale.getDefault())
   val calendar = Calendar.getInstance()
   // Create a list of dates starting with the current date and the following 3 dates
   repeat(4) {
       options.add(formatter.format(calendar.time))
       calendar.add(Calendar.DATE, 1)
   }
   return options
}
In OrderViewModel class, add a class property called dateOptions that's a val. Initialize it using the getPickupOptions() method you just created.

val dateOptions = getPickupOptions()
Update the layout to display pickup options
Now that you have the four available pickup dates in the view model, update the fragment_pickup.xml layout to display these dates. You will also use data binding to display the checked status of each radio button and to update the date in the view model when a different radio button is selected. This implementation is similar to the data binding in the flavor fragment.

In fragment_pickup.xml:

Radio button option0 represents dateOptions[0] in viewModel (today)

Radio button option1 represents dateOptions[1] in viewModel (tomorrow)

Radio button option2 represents dateOptions[2] in viewModel (the day after tomorrow)

Radio button option3 represents dateOptions[3] in viewModel (two days after tomorrow)

In fragment_pickup.xml, for the option0 radio button, use the new layout variable, viewModel to set the checked attribute based on the date value in the view model. Compare the viewModel.date property with the first string in the dateOptions list, which is the current date. Use the equals function to compare and the final binding expression looks like the following:
@{viewModel.date.equals(viewModel.dateOptions[0])}

For the same radio button, add an event listener using listener binding to the onClick attribute. When this radio button option is clicked, make a call to setDate() on viewModel, passing in dateOptions[0].
For the same radio button, set the text attribute value to the first string in the dateOptions list.

<RadioButton
   android:id="@+id/option0"
   ...
   android:checked="@{viewModel.date.equals(viewModel.dateOptions[0])}"
   android:onClick="@{() -> viewModel.setDate(viewModel.dateOptions[0])}"
   android:text="@{viewModel.dateOptions[0]}"
   ...
   />
Repeat the above steps for the other radio buttons, change the index of the dateOptions accordingly.

<RadioButton
   android:id="@+id/option1"
   ...
   android:checked="@{viewModel.date.equals(viewModel.dateOptions[1])}"
   android:onClick="@{() -> viewModel.setDate(viewModel.dateOptions[1])}"
   android:text="@{viewModel.dateOptions[1]}"
   ... />

<RadioButton
   android:id="@+id/option2"
   ...
   android:checked="@{viewModel.date.equals(viewModel.dateOptions[2])}"
   android:onClick="@{() -> viewModel.setDate(viewModel.dateOptions[2])}"
   android:text="@{viewModel.dateOptions[2]}"
   ... />

<RadioButton
   android:id="@+id/option3"
   ...
   android:checked="@{viewModel.date.equals(viewModel.dateOptions[3])}"
   android:onClick="@{() -> viewModel.setDate(viewModel.dateOptions[3])}"
   android:text="@{viewModel.dateOptions[3]}"
   ... />
Run the app and you should see the next few days as pickup options available. Your screenshot will differ depending on what the current day is for you. Notice that there is no option selected by default. You will implement this in the next step.
b55b3a36e2aa7be6.png

Within the OrderViewModel class, create a function called resetOrder(), to reset the MutableLiveData properties in the view model. Assign the current date value from the dateOptions list to _date.value.

fun resetOrder() {
   _quantity.value = 0
   _flavor.value = ""
   _date.value = dateOptions[0]
   _price.value = 0.0
}
Add an init block to the class, and call the new method resetOrder() from it.

init {
   resetOrder()
}
Remove the initial values from the declaration of the properties in the class. Now you are using the init block to initialize the properties when an instance of OrderViewModel is created.

private val _quantity = MutableLiveData<Int>()
val quantity: LiveData<Int> = _quantity

private val _flavor = MutableLiveData<String>()
val flavor: LiveData<String> = _flavor

private val _date = MutableLiveData<String>()
val date: LiveData<String> = _date

private val _price = MutableLiveData<Double>()
val price: LiveData<Double> = _price
Run your app again, notice today's date is selected by default.
bfe4f1b82977b4bc.png

Update Summary fragment to use view model
Now let's move onto the last fragment. The order summary fragment is intended to show a summary of the order details. In this task, you take advantage of all the order information from the shared view model and update the onscreen order details using data binding.

78f510e10d848dd2.png

In fragment_summary.xml, make sure you have the view model data variable, viewModel declared.

<layout ...>

    <data>
        <variable
            name="viewModel"
            type="com.example.cupcake.model.OrderViewModel" />
    </data>

    <ScrollView ...>

    ...
In SummaryFragment, in onViewCreated(), make sure binding.viewModel is initialized.
In fragment_summary.xml, read from the view model to update the screen with the order summary details. Update the quantity, flavor, and date TextViews by adding the following text attributes. Quantity is of the type Int, so you need to convert it to a string.

<TextView
   android:id="@+id/quantity"
   ...
   android:text="@{viewModel.quantity.toString()}"
   ... />

<TextView
   android:id="@+id/flavor"
   ...
   android:text="@{viewModel.flavor}"
   ... />

<TextView
   android:id="@+id/date"
   ...
   android:text="@{viewModel.date}"
   ... />
Run and test the app to verify that the order options you selected show up in the order summary.
7091453fa817b55.png